
\chapter{Design of Module \textit{virtualmemory}}

% ================================================================================= %
\section{Assignment Requirements}


\subsection{Initial Functionality}

\subsubsection*{Per Process Quotas}

The processes are currently allowed to open as many files as they want and also use as many physical frames as they want.

\subsubsection*{Zero Pages}

The OS doesn't allow allocating pages which are zero-initialized. Any attempt to do so will result in an assertion failure.

\subsection{Requirements}

\subsubsection*{Per Process Quotas}

The processes are limited (each one) to a maximum number of 16 open files and 16 physical frames. If a process attempts to exceed these limits, it will be prevented. In the case of files, it will be prevented from opening another one until one is closed, and in the case of physical frames, one of them will be swapped to the disk.

\subsubsection*{Zero Pages}
For implementing zero pages allocation, a change has to be done in \lstinline|VmmAllocRegionEx()| in which the zero allocation assertion has to be removed and the function has to be updated with an implementation which allocates pages with zero bytes.

\subsection{Basic Use Cases}

\subsubsection*{Per Process Quotas}
Process quotas limit how many resources a process can use, which results in fair allocation and prevention of system instability. By applying these rules, the OS ensures that no process can overwhelm its resources.

\subsubsection*{Zero Pages}
Zero Pages are used for performance optimization in the OS. They allow the apps to allocate memory pages which are initialized to zero, thus resulting in clean and secure memory allocation. It is very helpful when the apps need predictable or sanitized memory for working.
% ================================================================================= %
\section{Design Description}

\subsection{Needed Data Structures and Functions}

\subsubsection*{Per Process Quotas}

\begin{lstlisting}
typedef struct _PROCESS 
{
    ...
    DWORD FramesNo;
    DWORD FilesNo;
} PROCESS, *PPROCESS;
\end{lstlisting}

\noindent These 2 fields are kept in each process and they count the number of currently opened files and used frames. They are used to prevent a process for exceeding the limit of 16 opened files simultaneously and 16 physical frames. Updated functions:

\begin{itemize}
    \item \lstinline|SyscallFileCreate()|: will increment the \lstinline|FilesNo| field. If the limit is reached, further openings will be prevented until a file is closed.

    \item \lstinline|SyscallFileClose()|: will decrement the \lstinline|FilesNo| when an open file is closed.

    \item \lstinline|SyscallVirtualAlloc()|: will increment the \lstinline|FramesNo| field. If the limit is reached, the swapping mechanism is triggered to move a frame to the disk.
    
    \item \lstinline|SyscallVirtualFree()|: will decrement the \lstinline|FramesNo| field when a frame is freed.
\end{itemize}

\noindent Also we may create an error status if the quota is exceeded: \newline \lstinline|#define STATUS_QUOTA_EXCEEDED ((STATUS)0xC0000044L)|

\subsubsection{Zero Pages}
The function \lstinline|VmmAllocRegionEx()| will be modified to remove the assertion \lstinline|ASSERT(!IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_ZERO));| . This will be replaced with an implementation which initializes the allocated memory to zero by using the \lstinline|memzero()| function.

\subsection{Interfaces Between Components}

\subsubsection*{Per Process Quotas and Zero Pages}
They interact with the function \lstinline|VmmSolvePageFault()|. It happens when a process exceeds the number of allowed physical frames (the field \lstinline|PROCESS_MAX_PHYSICAL_FRAMES| in the file \lstinline|process_internal.h|). The components also interact with the system calls to the virtual memory system management and the stack growth by keeping track of the number of allocated frames. 

\subsection{Analysis and Detailed Functionality}

\subsubsection*{Per Process Quotas}

\begin{lstlisting}
STATUS
SyscallFileCreate(
    IN_READS_Z(PathLength) char*   Path,
    IN QWORD                       PathLength,
    IN BOOLEAN                     Directory,
    IN BOOLEAN                     Create,
    OUT UM_HANDLE*                 FileHandle
)
{
    ...
    currentProcess = GetCurrentProcess();

    // ---> Check the quota before trying to open a new file <---
    if (currentProcess->FilesNo >= PROCESS_MAX_OPEN_FILES)
    {
        return STATUS_QUOTA_EXCEEDED;
    }
    ...

    if (!SUCCEEDED(status))
    {
        IoCloseFile(fileObj);
        return status;
    }

    // ---> Increment the number of opened files <---
    AtomicIncrement32((volatile DWORD*)&currentProcess->FilesNo);
    // we include the atomic functions from "cal_atomic.h"

    *FileHandle = (UM_HANDLE)handle;

    return STATUS_SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}
STATUS
SyscallFileClose(
    IN UM_HANDLE FileHandle
)
{
    ...
    IoCloseFile(fileObj);

    // --> Decrement the file counter <---
    if (currentProcess->FilesNo > 0)
    {
        AtomicDecrement32((volatile DWORD*)&currentProcess->FilesNo);
    }

    return STATUS_SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}
STATUS
SyscallVirtualAlloc(
    IN_OPT      PVOID                   BaseAddress,
    IN          QWORD                   Size,
    IN          VMM_ALLOC_TYPE          AllocType,
    IN          PAGE_RIGHTS             PageRights,
    IN_OPT      UM_HANDLE               FileHandle,
    IN_OPT      QWORD                   Key,
    OUT         PVOID*                  AllocatedAddress
)
{
    ...
    framesNeeded = (DWORD)(
        AlignAddressUpper(Size, PAGE_SIZE) / PAGE_SIZE
    );

    // ---> Check Frame Quota <---
    if (
        currentProcess->FramesNo + framesNeeded > 
        PROCESS_MAX_PHYSICAL_FRAMES
    )
    {
        // This is where Swapping would be triggered
        return STATUS_QUOTA_EXCEEDED; 
    }

    // Call internal VMM
    resultAddress = VmmAllocRegionEx(
        BaseAddress,
        Size,
        (VMM_ALLOC_TYPE)AllocType,
        (PAGE_RIGHTS)PageRights,
        FALSE,
        NULL,
        currentProcess->VaSpace,
        currentProcess->PagingData,
        NULL
    );
    if (resultAddress == NULL)
    {
        return STATUS_MEMORY_CANNOT_BE_COMMITED;
    }

    // ---> Update Frame Quota <---
    AtomicExchangeAdd32(
        (volatile DWORD*)&currentProcess->FramesNo, 
        framesNeeded
    );

    ....
}
\end{lstlisting}

\begin{lstlisting}
STATUS
SyscallVirtualFree(
    IN PVOID BaseAddress,
    IN QWORD Size,
    IN DWORD FreeType
)
{
    ...
    VmmFreeRegionEx(
        BaseAddress, 
        Size, 
        (VMM_FREE_TYPE)FreeType, 
        TRUE,
        currentProcess->VaSpace,
        currentProcess->PagingData
    );

    // ---> Decrement Frame Quota <---
    if (currentProcess->FramesNo >= framesFreed)
    {
        AtomicExchangeAdd32(
            (volatile DWORD*)&currentProcess->FramesNo, 
            -((INT32)framesFreed)
        );
    }
    else
    {
        currentProcess->FramesNo = 0;
    }

    ...
}
\end{lstlisting}

\subsubsection*{Zero Pages}

\begin{lstlisting}
PTR_SUCCESS
PVOID
VmmAllocRegionEx(
    IN_OPT  PVOID                   BaseAddress,
    IN      QWORD                   Size,
    IN      VMM_ALLOC_TYPE          AllocType,
    IN      PAGE_RIGHTS             Rights,
    IN      BOOLEAN                 Uncacheable,
    IN_OPT  PFILE_OBJECT            FileObject,
    IN_OPT  PVMM_RESERVATION_SPACE  VaSpace,
    IN_OPT  PPAGING_LOCK_DATA       PagingData,
    IN_OPT  PMDL                    Mdl
    )
{
    ...
    ASSERT(Mdl == NULL || 
           IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY)
    );

    // ---> Support zero pages initialization <---
    //ASSERT(!IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_ZERO));
    ...

    if (FileObject != NULL)
    {
        QWORD fileOffset;
        QWORD bytesRead;

        // make sure we read from the start of the file
        fileOffset = 0;

        status = IoReadFile(FileObject,
                            alignedSize,
                            &fileOffset,
                            pBaseAddress,
                            &bytesRead);
        if (!SUCCEEDED(status))
        {
            LOG_FUNC_ERROR("IoReadFile", status);
            __leave;
        }

        LOG_TRACE_VMM(
            "File size is 0x%X, bytes read are 0x%X\n", 
            alignedSize, 
            bytesRead
        );

        // zero the rest of the file
        ASSERT(alignedSize - bytesRead <= MAX_DWORD);

        // memzero the rest of the allocation 
        // (in case the size of the allocation is greater than the
        // size of the file)
        memzero(
            PtrOffset(pBaseAddress, bytesRead), 
            (DWORD)(alignedSize - bytesRead)
        );
    }
    // ---> Support zero pages initialization <---
    else if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_ZERO))
    {
        memzero(pBaseAddress, alignedSize);
    }
    ...
}
\end{lstlisting}

% ================================================================================= %
\section{Tests}

\subsubsection{Per Process Quotas}

\begin{itemize}
    \item \lstinline|ProcessQuotaGood()|: this test checks if the process can open and close a maximum number of 16 files without exceeding the limit. It keeps on opening and closing files, checking whether or not the OS properly handles the limits imposed and allows reopening files after they've been closed
    \item \lstinline|ProcessQuotaJustRight()|: this test checks if the process can open exactly 16 files (the limit). It checks whether or not no files are left open after they're closed, seeing if the OS correctly handles the file count
    \item \lstinline|ProcessQuotaMore()|: this test checks if the OS allows the process to open more than 16 files, by attempting to open 32. It expects failure when the limit is exceeded
\end{itemize}

\subsubsection{Zero Pages, together with Swapping}
\begin{itemize}
    \item \lstinline|SwapLinear()|: tests that the swapping method works smoothly for basic
    memory functions. It starts by creating a big block of memory and
    writing data in a precise pattern to each page. The test then checks if
    the data remains correct and consistent, even when some of the pages
    are changed out to disk and eventually brought back into physical memory.
    To further check the functioning, it substitutes the written data with
    zeros and checks that the memory accurately reflects the changes. This
    test covers the essential parts of swapping, like evicting pages, writing
    them to the swap partition, recovering them as needed, and con-
    firming that the memory contents are exactly as expected after both
    the data and zero-write operations.

    \item \lstinline|SwapMultiple()|: evaluates the swapping mechanism's dependability in a multi-process setting. It involves numerous processes allocating and accessing memory at the same time, placing the system under stress to handle simultaneous swapping activities. The test checks that the system stays stable and that each process can only access its own allocated memory, even when pages are switched out to disk and later swapped back into physical memory. To properly validate the system's stability, this operation is performed four times, confirming that the swapping capability functions consistently under repeated and concurrent memory demands.
    
    \item \lstinline|SwapMultipleShared()|: This test takes the multi-process swapping sce- nario a step further by providing shared memory between processes. It starts by allocating a 16MB block of shared memory, then spawns multiple child processes. Each child writes data to a specific portion of the shared memory, using a set pattern identical to earlier testing. Once all the child processes complete their tasks, the main process performs a thorough check to ensure the entire memory block is correct, while the child processes verify the bits they wrote to. This test ensures that shared memory is consistent and available to all processes, even when the shared pages are swapped to disk and brought back into physical memory.
    
    \item \lstinline|SwapZeros()|: This test makes sure that during the swapping operation, memory initialized to zero remains consistent. It starts by allocating a 256MB block of memory using the \lstinline|VMM_ALLOC_TYPE_ZERO| flag, which guarantees that the memory is initially filled with zeros. The test then checks each page in the block to confirm that all values remain zero. If any page contains a non-zero value, it triggers an error. This test is designed to verify that zero-initialized memory is properly handled, continues intact after being switched out to disk and back into physical memory, and avoids any corruption or unexpected changes along the way. 
    
    \item \lstinline|SwapZerosWritten()|: By guaranteeing that any modifications made to zero-initialized memory are maintained throughout the swapping procedure, this test builds upon the \lstinline|SwapZeros| test. As in the previous test, it starts by allocating memory initialized to zero and verifying that the first 16MB are all zeros. Following that, particular values are written to the remaining memory, and the test confirms that these values are appropriately stored. When pages are switched out to disk and then brought back into physical memory, this procedure guarantees that the swapping system treats altered memory consistently, preserving any modifications. The test confirms the system's capacity to retain data integrity and appropriately reflect updates made to memory, even under swapping situations.
\end{itemize}


% ================================================================================= %
\section{Observations}

It was an interesting and very useful assignment to work on. We have learnt how the virtual memory is managed on an OS.
